### 前言
如何来描述各种网络协议的具体配置内容？这个问题就和面对对象编程的第一步： **抽象** 异曲同工。
设想一个图书集团，如何在图书管理系统中来保存每一种书籍呢。大概会创建下面这样的一个类：
```python
class Book:
    def __init__(self, title:str, author:str, isbn:str, price:float):
        """
        Args:
            title: 书名
            author: 作者
            isbn: 国际标准书号
            price: 价格
        """
        self.title = title
        self.author = author
        self.isbn = isbn
        self.price = price
```
这个类的每一个实例代表每一种书籍，并且依据这个类在数据库中创建一个专门的表用来存储书记的元数据。

同样，在网络领域，如何表示如此多的网络协议呢，答案依然是使用统一的数据模型，例如本文讨论的 **YANG** 模型。
上述的书籍类可以表示为以下的YANG模式（被称为 **Schema**）：
```yang
container books { 
    list book { 
        key title; 
 
        leaf title { 
            type string; 
        } 
        leaf isbn { 
            type string; 
            mandatory true; # 表示这个属性是强制要求的
        } 
        leaf author { 
            type string; 
        } 
        leaf price { 
            type decimal64 { 
                fraction-digits 2; 
            } 
            units sim-dollar; 
        } 
    } 
}
```
其中`list`类似于**类**，`key`类似于**主键**代表了实例的唯一标识路径，`leaf`类似于类的**属性**；

如果用数据库来比较，`container`类似于**Database\Schema**，`list`类似于**Table**，`leaf`类似于**Column**。

### YANG文件的头信息
当然，以上只是一个简单的示例，实际的YANG模型可能会有一个头信息：

```yang
module bookzone-example { 
  yang-version 1.1; 
  namespace 'http://example.com/ns/bookzone'; 
  prefix bz; 
  revision 2018-01-01 { 
    description "Initial revision. A catalog of books."; 
  } 
  container books { 
    ......
  } 
}
```
1. 模块**module**的名称必须与文件名一致，例如上面的文件名应该为 `bookzone-example.yang`。
2. 命名空间**namespace**字段必须全球唯一，所以一般会用公司网址+一些内部的内容来确保全球唯一。如果是IETF组织使用的命名空间的开头是`urn:`，例如`urn:ietf:params:netconf:base:1.0`。
3. 前缀**prefix**是命名空间的缩写，理论上来说不要求唯一。
4. **revision**包含修订时间、描述等信息。

### 叶引用（leafref）
除了书本这个“类”之外，我们可能还会添加“用户”和“作者”两个类，它们可能是下面的形式：
```yang
container users { 
  list user { 
    key user-id; 
    leaf user-id { 
      type string; 
    } 
    leaf name { 
      type string; 
    } 
  } 
}

container authors { 
  list author { 
    key name; 
    leaf name { 
      type string; 
    } 
    leaf account-id { 
      type uint32 { 
        range 1001..999999; 
      } 
    } 
  } 
}
```

由于`container books`的定义里面，`author`只是一个简单的字符串，实际上应当是`authors`中的某个`author`的`leaf name`，类似于数据库中的外键概念，YANG中提供了`leafref`，将`books`中的`leaf author`改为下面这样：
```yang
leaf author { 
  type leafref { 
    path /authors/author/name; 
  } 
}
```
这样的话如果`/books/book/author`字段不在`/authors/author/name`这个列表中的话，配置的**有效性校验**就会报错

注：上面的例子使用的是绝对引用，当层级比较复杂时也可以采用相对引用

### 枚举（enumeration）
YANG支持**枚举**类型，比如我们想给书籍增加一个“语言”属性，可以如下添加和使用：
```yang
typedef language-type { 
  type enumeration { 
    enum arabic; 
    enum chinese; 
    enum english; 
    enum french; 
    enum moroccan-arabic; 
    enum swahili; 
    enum swedish; 
    ...
  } 
  description 
    "Primary language the book consumer needs to master "+ 
    "in order to appreciate the book's content"; 
}

leaf language { 
  type language-type; 
}
```
*YANG是区分大小写的，一个惯例是把标识符都用小写，即使是枚举类型也是*

### 联合（union）
YANG支持**联合**类型，比如数据的ISBN属性我们现在设计的也是普通的字符串，但是ISBN实际上有它特定的结构，而且有新旧两种类型，分别是13位和10位字符，同时可以使用pattern+正则表达式来约束这个属性的形式：
```yang
typedef ISBN-10-or-13 { 
  type union { 
    type string { 
      length 10; 
      pattern '[0-9]{9}[0-9X]'; # 9个数字，最后一位可以是数字或X
    } 
    type string { 
      length 13; 
      pattern '97[89][0-9]{10}'; # 开头是978或者979，后面跟10位数字
    } 
  } 
  description 
    "The International Standard Book Number (ISBN) is a unique numeric commercial book identifier. 
     An ISBN is assigned to each edition and variation (except reprintings) of a book. [source: 
wikipedia]"; 
  reference 
    "https://en.wikipedia.org/wiki/International_Standard_Book_Number";
}

leaf isbn { 
  type ISBN-10-or-13; 
}
```

### 树状结构表示
可以想到把这两个`container`也放到前面提的`bookzone-example.yang`文件里面看起来会有很多大括号，为了可读性也可以把YANG模型表示为以下的树状结构：

```
module: bookzone-example 
    +--rw authors 
    |  +--rw author* [name] 
    |     +--rw name          string 
    |     +--rw account-id?   uint32 
    +--rw books 
    |  +--rw book* [title] 
    |     +--rw title       string 
    |     +--rw isbn        string 
    |     +--rw author?     string 
    |     +--rw price?      decimal64 
    +--rw users 
       +--rw user* [user-id] 
          +--rw user-id    string 
          +--rw name?      string
```
其中：
- `?` 表示可选（optional）
- `*` 表示零个或多个（list）
- `rw` 表示可读可写
