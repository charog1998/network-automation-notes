### 默认值（default）
我们之前设计的购买行为显然需要传入一个**购买数量**的参数，但是在之前的设计中，没有对`number-of-copies`这个参数设置`mandatory true`属性：
```yang
...
action purchase { 
  input { 
    uses title-format-ref;
    leaf number-of-copies { 
      type uint32 { 
        range 1..999; 
      } 
    } 
  }
...
```
其实除了设置`mandatory true`属性，还可以为`number-of-copies`参数设置一个默认值`1`，这样在不传入这个参数时默认为购买1本。如下设置默认值：
```yang
...
action purchase { 
  input { 
    uses title-format-ref;
    leaf number-of-copies { 
      type uint32 { 
        range 1..999; 
      } 
      default 1;
    } 
  }
...
```

### 校验条件（must）
我们现在设计的书籍中的`price`属性是可选选项，既然是一个销售图书的管理系统，那么每本图书理应有一个价格，我们可以直接为`price`属性设置`mandatory true`属性。这样的话就要求我们每次添加新的`book`实体时就一定要传入一个`price`属性。可是万一系统需要在销售价格敲定前就能够添加`book`实体呢？

我们需要在购买行为发生前进行图书价格的判断，要求购买行为指向的`book`实体此时拥有`price`属性并且大于0即可。YANG模型中使用`must`关键字来实现：
```yang
...
action purchase { 
  input { 
    must "deref(format)/../price>0" { 
      error-message "Item not orderable at this time"; 
    }
    uses title-format-ref;
    leaf number-of-copies { 
      type uint32 { 
        range 1..999; 
      } 
      default 1;
    } 
  }
...
```
- 其中的`"deref(format)/../price"`被称为**XPath**，类似于**URI**主要用来指向资源位置。
- 由于`action purchase`中引入的书籍信息是`title-format-ref`，其中的`format`是指向对应实体的`/books/book/format/format-id`的叶子引用。通过`deref()`函数可以将`format`解析为对应`book`实体内部的`format-id`。
- 与操作系统中的文件路径类似，**XPath**中也是用`..`表示上一级。`format-id`的上一级即为`format`，而`price`就定义于`format`的下一级。
- 最后会比较这个`book`实体的`price`是否大于零，只有大于零时才能完成购买行为。

**XPath**的解析过程如下所示：
```sh
  +--rw books
  |  +--rw book* [title]
        ...
  |     +--rw format* [isbn] # 2. deref(format)/../
  |     |  +--rw isbn
  |     |  +--rw format-id   # 1. deref(format)/
  |     |  +--rw price?      # 3. deref(format)/../price
```

注意，这里不能简单地使用这个语句：`must "/books/book/format/price>0"`。这个XPath是从根节点`/`开始的，指向我们定义的`container books`内部。实际上这个`must`语句要求`list book`内的任一一个`book`实体的`price`大于零即可，显然与我们的需求不符。

另一个类似的情况是`/books/book/author`节点显然是`mandatory true`的，因此我们可以直接添加这个限制条件。在此时存在另一个实际问题，书籍的作者应当存在一个收款账户`account-id`，在前面的设计中这个节点是可选节点，我们当然也可以直接将它设为强制要求的。

但是市场部的同事表示希望在作者开通收款账户前就能添加`/authors/author`实体，这个也好解决，只需要保持原有的`/authors/author`定义不变，在`/books/book/author`下添加`must`条件即可：
```yang
container books { 
  list book { 
... 
    leaf author { 
      mandatory true;
      type leafref { 
        path /authors/author/name; 
      } 
      must 'deref(current())/../account-id' { 
        error-message 
          "This author does not yet have an account-id defined. 
          Books cannot be added for authors lacking one. 
          The Finance Department is responsible for assigning 
          account-id's to authors."; 
      }
    }
...
```
其中`deref(current())`表示当前节点，也就是`/authors/author/name`，使用`..`向上一级找到待添加的`author`实体，再向下找到`account-id`节点。后面没有任何的比较运算，表示我们只要求这个节点存在即可。

### 唯一值（unique）
可以注意到一个问题，`/books/book/format`的主键是`isbn`，但是在`title-format-ref`中的`format`指向的是`format-id`。而实际生活中，有可能存在某本书的某个版本在不同的出版社出版导致存在不同的ISBN码的情况，比如人民教育出版社在2020年出版了《小王子》的精装版，其ISBN可能为978-7-107-3xxxx-x。外语教学与研究出版社在2021年也出版了《小王子》的精装版，其ISBN可能为：978-7-5600-xxxx-x。

这样我们现在设计的**标题+版本**是无法准确定位到一个确定的`book`实体的，只能靠ISBN编码来区分。

当然，我们可以调整`title-format-ref`的定义令其指向`isbn`，但是我们的维护工程师发出了抗议：原来的日志中可以直接看到书籍的标题和版本，例如`purchase(title=活着,format-id=精装本)`，但是调整后就可能变成`purchase(isbn=9780140386332)`，这样就十分不直观，我们要求保留原来的引用方式！！！

好消息是，市场部的同事告诉我们虽然有好多种**精装版的《小王子》**，但是他们最后只会采用其中一种（可能是采购价更低或者是其他什么原因）。

由此我们想到，在`list format`中，不仅`isbn`这个主键要求**唯一性**，`format-id`也要求唯一性，可以通过`unique`关键字进行如下设置：
```yang
list format { 
  key isbn; 
  unique format-id;
  leaf isbn { 
    type ISBN-10-or-13; 
  } 
  leaf format-id { 
    mandatory true; 
    type identityref { 
      base format-idty; 
    } 
  } 
...
```

### 条件语句（when）
我们`/books/book/format`设计了一个容器`number-of-copies`，它表示某一种书的库存、预订数量等。显然这个属性只对物理意义上的书本有用，如果是以文件形式出售的书籍就不需要这个容器了。

幸好，我们已经设计了一个身份`identity file-idty`，它表示所有以文件形式存在的书籍版本。当某个`/books/book/format`的`format-id`属性是`identity file-idty`的派生类时，就可以省略`number-of-copies`这个容器，如下：
```yang
container number-of-copies { 
  when 'not(derived-from(../format-id, "bz:file-idty"))'; 
  config false; 
  leaf in-stock { 
    type uint32; 
  } 
  leaf reserved { 
    type uint32; 
  } 
  leaf available { 
    type uint32; 
  } 
}
```
表示当`format-id`不是`identity file-idty`的派生类时，才存在这个容器。从这个例子中也能看到**identity**的重要性，将来我们可以扩展其他文件类型的`format-id`，只需要添加新的基于`file-idty`的派生类`identity`即可。

### 另一个小问题
可以回顾下`grouping title-format-ref`的定义：
```yang
grouping title-format-ref { 
  leaf title { 
    type leafref { 
      path /books/book/title; 
    } 
  } 
  leaf format { 
    type leafref { 
      path /books/book/format/format-id; 
    } 
  } 
}
```
这个分组在购买和派送的时候会使用到，会存在一个潜在的问题：由于`path /books/book/title`和`path /books/book/format/format-id`都指向现在已有的所有标题和所有版本，这意味着可能存在一些**标题+版本**的组合实际上是不存在的，如果用这样的组合提交购买就会出现问题。

我们应该对`format-id`进行检查，根据这个组合中的`title`找到对应的`book`然后确认它是否有对应的`format-id`，实现如下：
```yang
grouping title-format-ref { 
  leaf title { 
    type leafref { 
      path /books/book/title; 
    } 
  } 
  leaf format { 
    type leafref { 
      path /books/book[title=current()/../title]/format/format-id; 
    } 
  } 
} 
```
其中使用方括号`[]`代表的过滤条件获取到特定`title`的`book`实体，然后再返回这个实体拥有的所有`format-id`。这样就不会导致我们所担心的问题了。

### 模式节点
我们现在考虑在`/users/user`下方添加一个`payment-methods`容器，用来表示用户的各种支付方式。并且在`action purchase`发生时也传入这个属性，代码如下：
```yang
container users { 
  list user { 
    ...
    container payment-methods { 
      list payment-method { 
        key "method id"; 
        leaf method { 
          type enumeration { 
            enum bookone-account; 
            enum credit-card; 
            enum paypal; 
            enum klarna; 
          } 
        } 
        leaf id { 
          type string; 
        } 
      } 
    }
    action purchase { 
      input {
        ...
        container payment { 
          leaf method { 
            type leafref { 
              path ../../../payment-methods/payment-method/method; 
            } 
          } 
          leaf id { 
            type leafref { 
              path "../../../payment-methods/"+ 
                  "payment-method[method=current()/../method]/id";  
            } 
          }
        }
      }
```
`input, output, choice, case, grouping, uses`这些节点被称为模式节点，它们在**XPath**中是需要跳过的。因此`path ../../../payment-methods/payment-method/method;`中，第一次`..`是从`method`跳转到了`payment`容器，第二次`..`是从`payment`跳转到了`purchase`动作，第三次`..`是从`purchase`跳转到了`user`（当前用户），接下来一路向下到`user/payment-methods/payment-method/method`

最后，在文件开头处添加`revision`信息：
```yang
revision 2025-12-17 { 
  description 
    "Added constraints that 
     - author needs to have an account set before listing a book 
     - number of copies in stock only shows for physical items 
     - makes a book not orderable unless it has a price 
     - book leafrefs are chained correctly 
     Added /users/user/payment-methods and a way to choose which 
     one to use in action purchase."; 
} 
```